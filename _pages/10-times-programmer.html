---
title: "[笔记]10x程序员工作法"
collection: cs
permalink: /cs/10-times-programmer
excerpt: ''
date: 2019-05-12
---
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 9.0.4 (457912)"/><meta name="author" content="韵萱 郝"/><meta name="created" content="2019-04-22 01:34:26 +0000"/><meta name="source" content="desktop.mac"/><meta name="updated" content="2019-05-11 20:22:26 +0000"/><title>10x程序员工作法</title></head><body style="zoom: 1.052867;"><div><span style="color: rgb(146, 146, 146);">by郑晔 @极客时间 💰¥79</span></div><div><hr/><div>🎯建立思考框架，迭代自动化的高效工作流，以降低问题的偶然复杂度，成为优秀的程序员</div><div><span style="font-size: 14px; color: rgb(145, 145, 145);">【本质复杂度】解决一个问题时，无论怎么做都必须要做的事</span></div><div><span style="font-size: 14px; color: rgb(145, 145, 145);">【偶然复杂度】因为选用的做事方法不当，而导致要多做的事。</span></div><div><span style="font-size: 14px;"><br/></span></div><div><span style="font-size: 14px; color: rgb(145, 145, 145);">▶️</span><span style="color: rgb(145, 145, 145);">明确现状</span></div><ol><li><div>以终为始：</div></li><div>🎯明确目标：正确、边界清晰</div><div><span style="color: rgb(255, 126, 121);">#遇到事情，倒着想。第一反应应该是梳理功能细节，而不是美滋滋践行新学的技术。</span></div><div><span style="color: rgb(146, 144, 0);">任何事物都要经过两次创造：</span></div><div><span style="color: rgb(146, 144, 0);">一次是在头脑中的创造，也就是智力上的或者第一次创造（Mental/First Creation)，</span></div><div><span style="color: rgb(146, 144, 0);">然后才是付诸实践，也就是实际的构建或第二次创造（Physical/Second Creation)。</span></div><div>对于做软件，‘终’是“对用户有价值的软件”，可以通过以下方法降低实际开发的成本：</div><ul><li><div>if 要给用户看产品样子➜先做原型(Prototype/Demo/POC<span style="color: rgb(146, 146, 146);"> Proof Of Conception 概念证明</span>)</div></li><li><div>if 呈现服务接口➜用模拟服务器搭建 🔧<a href="https://github.com/dreamhead/moco">moco</a></div></li><li><div>if 让程序员知道开发细节➜描述场景、行为</div></li></ul><div>❗️提前准备，做好第一次创造：</div><ol><li><div>准备迭代0 🎯根据优先级确定迭代1要做的需求，然后细化</div></li><div><img src="/images/10-times-programmer/9C377E65-8F53-4128-A0CA-F00C522B9D52.png" height="509" width="687"/><br/></div><li><div>需求：</div></li><div>明确要做什么：</div><ul><li><div>对于业务场景明确的需求：使用用户故事清晰界定</div></li></ul><div style="margin-left: 40px;"/><div style="margin-left: 40px;"><span style="color: rgb(146, 146, 146);">【用户故事(User Story)】 🎯细化出有价值的需求</span></div><ul><ul><li><div><span style="color: rgb(146, 146, 146);">标题，简要地说明这个用户故事的主要内容，比如：注册用户使用用户名密码登录。</span></div></li><li><div><span style="color: rgb(146, 146, 146);">概述，简要地介绍这个用户故事的主要内容，一般会用这样的格式：</span></div></li></ul></ul><div style="margin-left: 80px;"><span style="color: rgb(146, 146, 146);">As a （Role）, I want to （Activity）, so that （Business Value）.</span></div><div style="margin-left: 80px;"><span style="color: rgb(146, 146, 146);">没有这个功能时，用户是怎样完成这个事情的，有没有其他方式可以达到目的。</span></div><div style="margin-left: 80px;"><span style="color: rgb(146, 146, 146);">举个概述的例子：作为一个注册用户，我想要通过用户密码登录，以便我可以使用注册用户才能够使用的服务。</span></div><ul><ul><li><div><span style="color: rgb(146, 146, 146);">详述，详细地描述这个用户故事的完整流程，我们会把操作流程、用户界面等信息都放到这里。</span></div></li></ul></ul><div style="margin-left: 80px;"><span style="color: rgb(146, 146, 146);">比如：用户使用正确用户名和密码登录，就可以登录成功；如果密码不正确，则登录页面提示用户“用户名密码不正确”。基本上，看到这个部分，程序员就可以在心中描绘出这个用户故事的样子了。</span></div><div style="margin-left: 80px;"><span style="color: rgb(146, 146, 146);">列出超出范围的部分，比如：第三方登录不在范围内，这个部分主要是限定人们不要进一步发散。</span></div><ul><ul><li><div><span style="background-color: rgb(255, 250, 165); color: rgb(146, 146, 146);-evernote-highlight:true;">验收标准</span><span style="color: rgb(146, 146, 146);">，这个部分会描述一个正常使用的流程是怎样的，以及各种异常流程系统是如何给出响应的，这是程序员常常会欠缺的思考。它会把详述中很多叙述的部分变成一个具体的测试用例。</span></div></li></ul></ul><div style="margin-left: 80px;"><span style="color: rgb(146, 146, 146);">//依照BDD行为驱动开发。Java的BDD框架： JBehave, JDave, beanSpec, Instinct</span></div><div style="margin-left: 80px;"><span style="color: rgb(146, 146, 146);">比如，下面我给出的两个验收用例：</span></div><ul><ul><ul><li><div><span style="color: rgb(146, 146, 146);">正常场景：给定一个注册用户张三，其用户名是 zhangsan，密码是 foobar，当张三使用 zhangsan 和 foobar 登录系统时，可以成功登录，登录成功后，跳转到用户中心。</span></div></li><li><div><span style="background-color: rgb(255, 250, 165); color: rgb(146, 146, 146);-evernote-highlight:true;">异常场景</span><span style="color: rgb(146, 146, 146);">：给定一个注册用户张三，其用户名是 zhangsan，密码是 foobar，当张三使用 zhangsan 和 wrong 登录系统时，登录失败，在登录页面上提示“用户名密码不正确”。</span></div></li></ul></ul></ul><div style="margin-left: 40px;"><span style="color: rgb(4, 51, 255);">假如你没有这个条件，就扮演产品经理的角色，在开发前先厘清需求。最重要的是明确验收标准‼️</span></div><ul><li><div>面向不确定性问题：试 🎯减少对不确定性产品的过度开发</div></li><ul><li><div>反馈循环：开发(build)-&gt;测量(measure)-&gt;‼️经过验证的认知(Validated Learning) </div></li></ul></ul><div style="margin-left: 80px;">➜idea-&gt;code产品投入市场-&gt;收集data，验证想法。</div><div style="margin-left: 80px;">➜通过制作最小可行产品(Minimum Viable Product)以最低成本尝试</div><ul><ul><li><div>工具：精益画布</div></li></ul></ul><div style="margin-left: 80px;"><img src="/images/10-times-programmer/B622B37D-2429-4708-AAEB-59DCD55015DC.png" height="297" width="668"/><br/></div><ul><ul><li><div><span style="color: rgb(145, 145, 145);">确认是否要做该产品特性：</span><span style="color: rgb(255, 126, 121);">#默认所有需求都不做，直到弄清楚为什么要做这件事。</span><span style="color: rgb(255, 126, 121);">仔细想每个需求的正真解决目标问题，紧急度、优先级、验收标准…</span></div></li><ul><li><div><span style="color: rgb(145, 145, 145);">你要检证的东西是什么呢?他要验证的目标是否有数据可以度量呢?</span></div></li><li><div><span style="color: rgb(145, 145, 145);">要解决的这个问题是不是当前最重要的事情,是否还有其他更重要的问题呢?</span></div></li><li><div><span style="color: rgb(145, 145, 145);">验证这个目标是否有更简单的解决方案,是不是一定要通过开发一个产品特性来实现呢?</span></div></li></ul></ul><li><div>通过DoD清晰定义完成 🎯同步团队间对完成的定义 <input type="checkbox"/>把DoD放入奇妙清单</div></li><li><div>先推演，然后拿出详细的实施方案：</div></li><ul><li><div>先从结果的角度入手,看看最终上线要考虑哪些因素</div></li><li><div>推演出一个可以一步一步执行的上线方案,用前面考虑到的因素作为衡量指标。</div></li><li><div>根据推演出来的上线方案,总结要做的任务</div></li></ul></ul><li><div>技术：</div></li><ul><li><div>构建脚本：编译打包，测试，构建 IDE 工程、代码风格检查、常见的 bug 模式检查、测试覆盖率…</div></li><li><div>CI Monitor ：把持续集成的状态展示 🔧Cucumber</div></li><li><div>管理数据库变更：数据库迁移…… 🔧flyway</div></li><li><div>把部署/发布自动化 by Docker/shell</div></li><li><div>风险准备：如何快速恢复服务，如何回滚版本、回滚数据库</div></li><li><div>用数字衡量工作 🌰测试覆盖率，API调用时间、次数</div></li></ul><li><div>工作</div></li></ol><ul><ul><li><div>向上管理：</div></li><ul><li><div>发挥上级的长处，以其能接受的方式向其提出建议</div></li><li><div>❗️敢于对不合理要求说“不”</div></li><li><div>管理上级的预期 把你看到的问题暴露给上级</div></li><li><div>帮助上级丰富知识</div></li><li><div>说出你的想法</div></li></ul><li><div>拓宽工作的上下文：</div></li><ul><li><div>找到你和你的下一步职业目标的差异</div></li><li><div>很多时候跳出程序员角色，技术不再是问题</div></li><li><div>多了解别人的工作逻辑，认识软件开发的全生命周期</div></li><li><div>多了解一些上下文，你才有能力判断自己是否想多了。</div></li></ul></ul><li><div>实际操作</div></li><ul><li><div>倒排时间表：调整需求范围和资源配置</div></li><li><div>Amazon开发顺序：新闻稿➜FAQ➜用户文档➜代码 //</div></li><li><div>需求评审－技术方案评审－测试用例评审－写代码－测试－上线－测试。</div></li></ul></ul><div style="margin-left: 40px;"><br/></div><li><div>任务分解：</div></li><ul><li><div>🎯找到实现路径 ‼️<font color="#ff7e79">学习经验，收集错误/痛点/风险点</font></div></li><li><div>🏹将大目标拆分成<span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">可执行</span>任务序列。</div></li><div>检验标准：是否清晰知道如何行动。知道自己下一步要做什么，优先级-应对插入打断，需要哪些资源，有什么风险-什么时候能消除这部分不确定性，制定可完成的计划时间表。</div><li><div>🔑：小 ✅可以随时停下来 try粒度在1～3个番茄之间</div></li><li><div>🧠：分而治之</div></li><li><div>开发：feature -&gt; user story -&gt; task</div></li><li><div>#随着软件开发，软件变更成本在逐步增加</div></li><li><div>👍🏻测试金字塔：</div></li><ul><li><div>🧠：越是底层越多测试</div></li><li><div>🔑：多写单元测试</div></li><li><div>在本地运行单元测试和集成测试，在持续集成服务器上运行系统测试</div></li></ul><li><div>mvc结构的工程，c层的单元测试要实际的去调用m层吗？需要和数据库里的数据做比对和验证吗？如果不用，c层的单元测试应该验证或测试哪些内容呢？</div></li><ul><li><div>作者回复: 在单元测试里，M 的接口是可以用 Mock 的，这才算是单元测试。涉及到数据库，就变成了集成测试。</div></li></ul><li><div>测试驱动开发TDD（Test Driven Development/Design）</div></li><ul><li><div>❗️≠ 测试先行开发(先写测试后可代码)。区别在于<span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">重构</span>。</div></li><li><div><img src="/images/10-times-programmer/C56D56EA-9F20-45F3-ADCD-23867A22DDFB.png" height="830" width="864"/></div></li><li><div>思维上的转变：编写可测的代码</div></li></ul><li><div>开发守则：</div></li><ul><li><div>尽量不写 static 方法。</div></li><ul><li><div>除非它不涉及任何状态&amp;&amp;行为简单，如可以抽象出来做库函数的程度。</div></li><li><div>if 第三方的static，将其封装</div></li></ul><li><div>主分支开发模型是一种更好的开发分支模型</div></li></ul><li><div>极限编程：</div></li><ul><li><div>思想：把好的实践推向极限</div></li><li><div>实践：TDD、持续集成、结对编程、现场客户……</div></li></ul><li><div>最佳实践是，基于主分支的模型。大家都在同一个分支上进行开发</div></li><ul><li><div>一个是在已用线上产品的时候，我们通常会有一条release分支。这样当有线上bug出现的时候，我们能在release分支上快速修复 + 上线。</div></li><li><div>另外一个是，在规律性的迭代上线时，难免会遇到有story没有完成(开发或者测试)，此时，就得使用feature toggle 或者 revert代码了。</div></li><li><div>最后是当在做一个很明显上线前不可能完成的大feature的时候，一般我们会启另一条分支来开发。此时会定时从主分支merge代码，因为有些改动可能会影响已用的业务</div></li></ul><li><div>主分支开发模型 遭遇 多个功能同时开发：</div></li><ul><li><div>Feature Toggle：通过开关，决定哪个功能对外是可用的。//应该是一个非常临时的存在。除非在遗留系统上工作，功能要跨越很长周期。</div></li><ul><li><div><input type="checkbox"/><a href="https://martinfowler.com/articles/feature-toggles.html">https://martinfowler.com/articles/feature-toggles.html</a></div></li></ul><ul><li><div><input type="checkbox"/><a href="https://www.infoq.cn/article/function-switch-realize-better-continuous-implementations">https://www.infoq.cn/article/function-switch-realize-better-continuous-implementations</a></div></li></ul><li><div> <a href="https://www.martinfowler.com/bliki/BranchByAbstraction.html">Branch by Abstraction</a>：在动手改造前,先提取出来一个抽象,把原先的实现变成这个抽象的一个实现。改造的过程就是提供这个抽象的一个新实现。</div></li><li><div>✅在一个分支上进行</div></li><li><div>❎对设计能力有一定要求。对很多团队来说,这是一个挑战。</div></li></ul><li><div>写出思路、需要用到的知识点，api等，写出各个小任务，然后对应写出关键代码段。</div></li><li><div>开发实践中注意：</div></li><ul><li><div>数据库迁移别忘记</div></li><li><div>把需求分解到具体的方法和目标：</div></li><ul><li><div>领域对象,这里就是用户</div></li><li><div>数据访问层,在不同的项目里面叫法不一,有人从J2EE年代继承下来叫DAO(数据访问对象，Data Access Obejct），有人跟着Mybatis 叫 mapper，我现在更倾向于使用领域驱动设计的术语,叫 repository</div></li></ul><ul><li><div>服务层,提供对外的应用服务,完成业务处理</div></li><li><div>资源层,提供API接口,包括外部请求的合法性检查</div></li><li><div><img src="/images/10-times-programmer/B21E0AA0-0F3C-4118-AAD9-E35A61B19FFB.png" height="374" width="693"/></div></li><li><div>考虑分布式服务器</div></li><li><div><img src="/images/10-times-programmer/9B2F6130-194A-46F6-8C10-A6D039C69941.png" height="169" width="686"/></div></li><li><div><img src="/images/10-times-programmer/5F2E4076-3B7F-4016-ADD7-0BF5DA6F641C.png" height="123" width="686"/></div></li><li><div>访问控制：</div></li><li><div><img src="/images/10-times-programmer/FF3D67FF-90CE-4504-8540-C3C4078387A1.png" height="181" width="683"/></div></li></ul><li><div>调整依赖关系，按需求的完整实现来写，而非一个一个类</div></li></ul><li><div>根据现状制定改进路径，不要想着一步到位</div></li><li><div>分解不了解的技术任务：</div></li><ul><li><div>做一次<a href="https://blog.ming.ws/posts/read/10x-develop-technique/technical-spkie/#post">技术spike</a>，先将它变成熟悉的技术 <span style="color: rgb(255, 126, 121);">#⚠️发散</span></div></li><div>    0.  通过各种渠道(新闻网站、技术blog、上级安排……)对要使用的技术有感性的认识，知道他是干啥的。</div><ol><li><div>快速完成教程上的例子 (4-5h)</div></li><li><div>确定这项技术在项目中应用场景和我们的关注点。</div></li><div>//<span style="color: rgb(146, 146, 146);">‼️spike没有那么多时间通读文档！！！要针对最重要的场景选出几个最需要的功能。</span></div><div><span style="color: rgb(146, 146, 146);">‼️</span>要找准关注点。比如,采用新的缓存中间件是为了提高性能,那关注点就是性能,采用新的消息队列是为了提升吞吐,那关注点就是吞吐。我们选用一项新技术总是有自己的一些假设,但这些假设真的成立吗?这是我们需要验证的</div><li><div>验证想法，决定是否采纳这项技术。</div></li><li><div>‼️‼️假如确定使用，丢弃原型重新设计‼️‼️</div></li></ol></ul><li><div>怎么把新技术用在自己的项目中？</div></li><ul><li><div>思考这个问题重点要放在“自己的项目”而不是新技术。</div></li></ul><li><div>不要混淆目标与现状：</div></li><ul><li><div>【目标】应该怎么做</div></li><li><div>【现状】正在怎么做</div></li><li><div>‼️忙是不去思考改进的借口。假如不忙了，你知道该怎么改进吗？？！</div></li><li><div>以测试为例：</div></li><ul><li><div>🎯业务代码100%测试覆盖</div></li><li><div>任务分解：</div></li><ul><li><div>与人沟通：</div></li><ul><li><div>🎯与团队达成共识</div></li><li><div>🏹将最佳实践及背后的逻辑与之沟通，讲清Why，触发动机</div></li></ul><li><div>自动化：</div></li><ol><li><div>把测试覆盖率检查加入工程，得到现有的测试覆盖率</div></li><li><div>将测试覆盖率加入持续集成，设定当前测试覆盖率为初始值。测试覆盖率不达标,不许提交代码。</div></li><li><div>每周将测试覆盖率调高，比如：5%或10%，直到测试覆盖率达到100%</div></li></ol></ul></ul></ul><li><div>需求管理：</div></li><ul><li><div>‼️口头不算，全部文件邮件确认，存档。</div></li><li><div>区分优先级，尽可能把精力放在重要的事情上。 站在老板面前讲道理</div></li><div><img src="/images/10-times-programmer/1A0C77A6-FEFB-45EF-A503-BD4BD8C56441.png" height="391" width="515"/><br/></div><div><span style="color: rgb(146, 146, 146);">//艾森豪威尔矩阵（Eisenhower Matrix）</span></div><div><br/></div><div>🌰告诉老板:我资源有限,需要将这两个需求排个序,看哪个更重要。我的上下文有限,需要你帮我判断一下</div><div>老板会和你说这起两个需求的起源：</div><ul><li><div>扩展盈利的需求是竞争对手都已经有了客户也问这边要,再不做会影响客户关系,尤其是新财年快到了,下个阶段的合同会受到影响。</div></li><li><div>而另外的新业务是某天一个高端聚会上得到的新启发,想尝试一下,他也不确定这个想法能带来多少收益,就让产品部门试一下</div></li></ul></ul><div style="margin-left: 40px;">👍🏻可视化团队四象限：</div><div style="margin-left: 40px;">为了适当减少每次argue需求优先级带来的沟通成本，还可以把当前团队正在面对的四象限公示出来，让大家都能看到团队路线图，让提需求的人（产品经理更需要）看看自己的需求在哪个象限，什么优先级，有时候他们自己就明白了</div><li><div>需求分解：</div></li><ul><li><div>一般用户故事经两次拆分，先是业务，再是估算时拆小它。</div></li><li><div>🌰用户登录是一个master story，可以拆分成第三方验证，邮箱地址验证，登录验证码……</div></li><li><div>好的细分需求的衡量标准：INVEST原则</div></li><ul><li><div>Independent 独立性：一个用户故事完成一个独立的功能，如果有依赖，将该部分拆出来，重新调整 //2019/4/28 其实依赖那里没有看懂，抽出来不还是要依赖吗？是开发依赖还是业务依赖</div></li><li><div>Negotiable 可协商性：主动提问理清需求</div></li></ul><div style="margin-left: 40px;">🌰<span style="color: rgb(145, 145, 145);">需求管理中印象最深的是刚进入开发行业时的一段经历。当时要显现某种单据，单据本身还嵌套子单据，原始需求是单据按层次显示，但某变量等于某个值时，某层次的单据就隐藏，但它的再下一层子单据需要显示。解决方案简单可以理解成页面要用递归方式才能正确显示。当时一心想显示自己牛鼻，因为无法用通常的页面模版机制，就自己写工具递归生成页面代码，看起来代码很巧妙，但别人难以维护。后来有段小插曲，若干年后项目移交到另外一个研发中心时，还需要有人专门去讲这段代码，否则接手人很难理解。再说回到之前，开发完后有一次和业务分析员再次聊起，说这个很不好实现但我啃下来了等等，他说那可以不用隐藏，显示空白层也可以，真如果这样实现就简单多了，也好理解多了。事不大，但在职业生涯里印象深刻。需求不光是拆解，更可以讨论后寻找简单解决方案，而不是用自以为牛鼻的代码实现。以更合理的成本实现需求交付价值，这其实是用户故事里Negotiable的意义所在</span></div><ul><li><div>Valuable 有价值的：</div></li><ul><li><div>这个功能不做，用户会怎样？有没有什么替代方案。</div></li></ul><li><div>Estimatable 可估算的：</div></li><ul><li><div>假如不能估算，要么因为还有很多不确定因素，要么因为需求还是太大，都没到可开发的状态。</div></li><li><div>❗️How：分解好用户故事之后从中挑出最简单的作为基准，其他任务清单和它相比的复杂度给个估计。</div></li><li><div>假如大家估算差异过大，是因为对需求的理解出现了巨大的差异。</div></li></ul><li><div>Small 小：小才方便调度和安排工作</div></li><li><div>Testable 可测试的</div></li></ul><li><div>面对不确定的产品：最小可行产品（Minimum Viable Product，MVP）</div></li><ul><li><div>❗️最小的代价：</div></li><ul><li><div>🧠：能不做就不做，能简化就简化</div></li><li><div>‼️我们要做的是验证一个想法的可行性，甚至不是为了开发一个软件，不要把解决方案当作问题。</div></li><li><div>🌰想做物联网相关项目：</div></li><ol><li><div>做产品文档，让销售拿给用户看。➜ 验证已有设备进行物联网改造的需求确实存在。额外收获：知道客户能接受的价格区间</div></li><li><div>用原型工具做界面和产品交互，用户可以实际体验➜根据用户真实反馈，调整产品设计</div></li><li><div>整理反馈，决定哪些可以真正开发出来，进入开发阶段</div></li></ol></ul><li><div>可行的路径：</div></li><ul><li><div>🧠：可行不是模块多么完整，而是用户路径是否畅通</div></li><li><div>🌰：P2P项目(个人对个人互联网借贷平台)，项目方希望尽快上线：</div></li><ul><li><div><span style="color: rgb(255, 126, 121);">#当时间有限时，我们需要学会找到一条可行的路径，在完整用户体验和完整系统之间，找到一个平衡。</span></div></li><li><div>业务模型：贷款方贷款之后，一次性拿到所有的钱，然后用等额本息的方式每个月还款，最后一个月剩多少钱一次性全还了。</div></li></ul></ul></ul><ul><ul><ol><li><div>第一次上线，1个月后➜只做最基本的还是不够时间➜第一版只包含贷款能力</div></li><li><div>两周一迭代，一个半月后上线了每期等额本息还款。</div></li><li><div>基础上慢慢叠加，但用户发现不了，它的视角始终是个完整的平台</div></li></ol></ul><li><div>总的来说，小步快跑。先弄清客户想要什么，整理后再用自己的语言复述一遍，后面拿着原型+业务交互给客户确认，同时把自己的设计理念植入进去和客户探讨，有些点对方之前也没有想清楚，尤其是实现方面需要专业的软件意见去参考，而我们再从探讨中更新自己的认知，如此往复几次，大方向上就不会有偏差，后面在实施过程中再局部调整。尤其是对于不确定性很高或者从零开始的工作，这是个可操作的方式。</div></li></ul></ul><li><div>测试：</div></li><ul><li><div>阶段：</div></li><ol><li><div>前置准备：准备依赖 e.g：组件(使用mock隔离)、参数</div></li><li><div>❗️执行：一般就一行代码的调用</div></li><li><div>断言：我们的预期，就是这段代码执行出来怎么算是对的 //不只是assert，mock框架的verify</div></li><li><div>清理： 释放资源 //利用好现有的测试基础设施（比如，JUnit 的 Rule），遵循好测试规范的话，很多情况下，这个部分就会省掉了。</div></li></ol><li><div>🎯A-TRIP：</div></li><ul><li><div>Automatic，自动化：尽可能交给机器，人工参与越少越好。</div></li><li><div>Thorough，全面的：</div></li><ul><li><div>写代码前：考虑各种场景：正常的、异常的、各种边界条件</div></li><li><div>代码写好后：看测试是否覆盖了所有的代码和所有的分支</div></li><li><div>if在补测试，让测试覆盖率逐步提升是个好方法</div></li></ul><li><div>Repeatable，可重复的：</div></li><ol><li><div>反复运行结果应相同</div></li><li><div>测试本身不依赖于任何不再控制下的环境：</div></li><ul><li><div>外部依赖➜模拟服务 <a href="https://github.com/dreamhead/moco">🔧Moco:模拟外部HTTP服务</a></div></li><li><div>依赖数据库➜测试完后回滚数据库 🌰SpringBoot@Transactional</div></li><li><div>CI的数据库是共用的，没有本地的那份初始化数据集</div></li><ul><li><div>➜保持数据库干净，用测试时用初始化脚本准备数据</div></li><li><div>➜如果测的场景比较复杂，比如要测多个事务的交互结果，还可以引入Docker，将依赖的数据库及初始化数据做成Docker的image，测试代码就更加简单，并且可以重复运行了，只要CI支持Docker即可</div></li></ul><li><div>测试代码中尽量避免与数据库打交道，测试更关注领域与业务，往往爆雷更多的是resource和service，模型的变化往往牵动着表结构的变化，与其两头兼顾不如多聚焦模型，我常用的做法是用例配合若干小文件(数据忠实于模型)，保证库操作临门一脚前所有环节都是正确的，同时方便适应变化。一旦出现异常，也比较容易定位是否是数据库操作引发的问题。(此点基于工作中发现项目型程序员大多是先急于把表结构定义出来，好像不这么做写代码就不踏实) //2019/4/27 虽然没太看懂</div></li></ul></ol><li><div>Independent，独立的：测试不相互依赖 </div></li><ul><li><div>if多个测试有相同的准备和清理➜use setup &amp; teardown </div></li></ul><li><div> Professional，专业的：按代码的标准维护</div></li><ul><li><div>比如：良好的命名，把函数写小，要重构，甚至要抽象出测试的基础库，🌰 Web 测试中常见的 PageObject 模式</div></li></ul></ul><li><div>👍🏻简单到一目了然，不需要证明它的正确性</div></li></ul><div style="margin-left: 40px;"><img src="/images/10-times-programmer/BC906824-0DF5-4CBF-A52B-A8203EF19702.png" height="304" width="496"/><br/></div><ul><li><div>👎🏻：</div></li><ul><li><div>一个测试做很多事。🌰出现了几个不同的方法的调用 ➜拆分成几个测试</div></li><li><div>没有断言 Hmm……</div></li><li><div>复杂 🌰出现判断/循环语句➜判断 拆分 每个测试覆盖一种场景 | 循环 测试等价类-&gt;用少量数据</div></li></ul></ul></ul><li><div>沟通反馈：校正路径 | 解决与人打交道出现的问题</div></li><li><div>自动化：优化提高效率、减少非必要支出上的时间消耗 | 解决与机器打交道出现的问题</div></li></ol><div><br/></div></div><div><br/></div><div>🌰开发新的功能特性：</div><ol><li><div>为什么要做这个特性，他给用户带来的价值</div></li><li><div>具体的使用场景，实现的优先级</div></li><li><div>确保自己的理解与需求一致，上线后质量如何➜调整下次开发</div></li><li><div>了解自动化之前的方案，有无其他替换方案。</div></li></ol><div><br/></div><div><br/></div></body></html>
